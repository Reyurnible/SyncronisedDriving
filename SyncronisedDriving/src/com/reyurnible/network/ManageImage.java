package com.reyurnible.network;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import org.apache.http.entity.mime.content.ByteArrayBody;import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Canvas;import android.graphics.Matrix;import android.graphics.Bitmap.CompressFormat;import android.graphics.drawable.BitmapDrawable;import android.net.Uri;import android.os.Environment;import android.widget.ImageView;public class ManageImage {	public static String savePicture(ImageView itemImage,int id) throws IOException {		try{			String dirPath = Environment.getExternalStorageDirectory()+"/Melo/";			File outDir = new File(dirPath);			if(!outDir.exists()){				outDir.mkdir();			}			String fileName="meloItem"+Integer.toString(id);	        // ImageViewをビットマップにキャスト	        BitmapDrawable bd = (BitmapDrawable)itemImage.getDrawable();	        // getBitmapメソッドでビットマップファイルを取り出す。	        Bitmap data = bd.getBitmap();	        File file = null;			file = new File(dirPath+fileName+".png");			if(writeImage(file,data)){				return file.getPath();			}		}catch(Exception e){			e.printStackTrace();		}		return null;    }	public static boolean writeImage(File file,Bitmap mBitmap){		try{			FileOutputStream fo = new FileOutputStream(file);			mBitmap.compress(CompressFormat.PNG,100, fo);			fo.flush();			fo.close();		}catch(Exception e){			System.out.println(e.getLocalizedMessage());			return false;		}		return true;	}		public static Bitmap loadImage(Context context,Uri uri)throws IOException{		//画面の向きを管理する。		boolean landscape = false;		Bitmap bm;		BitmapFactory.Options options = new BitmapFactory.Options();		options.inJustDecodeBounds=true;		InputStream is = context.getContentResolver().openInputStream(uri);		BitmapFactory.decodeStream(is,null,options);		is.close();		int width = 360;		int height = 360;		int oh=options.outHeight;		int ow=options.outWidth;		//画面が横になっていたら。		if(ow>oh){			landscape = true;			//縦と横を逆にする。			oh=options.outWidth;			ow=options.outHeight;		}		options.inJustDecodeBounds=false;		options.inSampleSize=Math.max(ow/width,oh/height);		InputStream is2 = context.getContentResolver().openInputStream(uri);		bm = BitmapFactory.decodeStream(is2,null,options);		is2.close();		if(landscape){			Matrix matrix = new Matrix();			matrix.setRotate(90.0f);			bm = Bitmap.createBitmap(bm,0,0,bm.getWidth(),bm.getHeight(),matrix,false);		}		bm = Bitmap.createScaledBitmap(bm, (int)width, (int)(width*((double)oh/(double)ow)),false);		Bitmap offBitmap = Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);		Canvas offCanvas = new Canvas(offBitmap);		offCanvas.drawBitmap(bm, 0, (height-bm.getHeight())/2,null);		bm=offBitmap;		return bm;	}		private static Bitmap resize(Bitmap picture, int targetWidth, int targetHeight) {	    if (picture == null || targetWidth < 0 || targetHeight < 0) {	        return null;	    }	    int pictureWidth = picture.getWidth();	    int pictureHeight = picture.getHeight();	    float scale = Math.min((float) targetWidth / pictureWidth, (float) targetHeight / pictureHeight); // (1)	    Matrix matrix = new Matrix();	    matrix.postScale(scale, scale);	    	    return Bitmap.createBitmap(picture, 0, 0, pictureWidth, pictureHeight, matrix, true);	}		public static ByteArrayBody toByteArrayBody(Bitmap picture) {    	if (picture == null) {    		return null;    	}    	ByteArrayOutputStream bos = new ByteArrayOutputStream();    	picture.compress(CompressFormat.JPEG, 100, bos); // (4)      	byte[] data = bos.toByteArray();      	return new ByteArrayBody(data, System.currentTimeMillis() + ".jpg");    }}